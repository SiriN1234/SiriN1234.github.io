<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="재귀함수자신을 정의할 때 자신을 리턴하는 함수다시(재) 귀환(귀) 하는 함수
stack overflow나중에 들어간게 먼저 나온다제일 최근에 호출된 함수의 리턴 값이 먼저 계산되어야 한다하나가 끝나기 전에 새로운 하나가 호출되고 그것을 처리하기 전에 또 새로운 것이 호"/>
    

    <!--Author-->
    
        <meta name="author" content="SiriN"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="2022.06.21 수업내용과 실습"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="재귀함수자신을 정의할 때 자신을 리턴하는 함수다시(재) 귀환(귀) 하는 함수
stack overflow나중에 들어간게 먼저 나온다제일 최근에 호출된 함수의 리턴 값이 먼저 계산되어야 한다하나가 끝나기 전에 새로운 하나가 호출되고 그것을 처리하기 전에 또 새로운 것이 호"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="SiriN&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="https://SiriN1234.github.ioimg/home-bg.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="https://SiriN1234.github.ioimg/home-bg.jpg"/>
    

    <!-- Title -->
    
    <title>2022.06.21 수업내용과 실습 - SiriN&#39;s Blog</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet"/>

    <!-- Google Analytics -->
    


    <!-- favicon -->
    

</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Configurable Title</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-clean-blog">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>2022.06.21 수업내용과 실습</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                            Posted by Hanjeongin on
                        
                        
                            2022-06-21
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/Java/">#Java</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h2 id="재귀함수"><a href="#재귀함수" class="headerlink" title="재귀함수"></a>재귀함수</h2><p>자신을 정의할 때 자신을 리턴하는 함수<br>다시(재) 귀환(귀) 하는 함수</p>
<h2 id="stack-overflow"><a href="#stack-overflow" class="headerlink" title="stack overflow"></a>stack overflow</h2><p>나중에 들어간게 먼저 나온다<br>제일 최근에 호출된 함수의 리턴 값이 먼저 계산되어야 한다<br>하나가 끝나기 전에 새로운 하나가 호출되고 그것을 처리하기 전에 또 새로운 것이 호출되고<br>이게 끝없이 진행되어서 스택 오버 플로우가 발생한다</p>
<h2 id="컬렉션-Collection"><a href="#컬렉션-Collection" class="headerlink" title="컬렉션(Collection)"></a>컬렉션(Collection)</h2><p><a target="_blank" rel="noopener" href="https://st-lab.tistory.com/240">자료</a></p>
<p>자바에서 1.2에서 정의됨.<br>자바에서 미리 만들어놓은 데이터를 수집하고 관리(추가,생성,삭제,초기화,크기,리스트)해주는 목적의 클래스와 인터페이스</p>
<ul>
<li><p>왜사용하는가? </p>
<ul>
<li>일관된 API(Application Programming Interface)</li>
<li>프로그래밍의 노력 감소 &#x2F;&#x2F; 바퀴를 또 발명하지 말라(이미 구현 된 것을 또 개발할 필요 없음)</li>
<li>프로그램 속도 및 품질 향상</li>
</ul>
</li>
<li><p>선언법<br>(<strong>중요</strong>)   컬렉션종류&lt;데이터타입&gt; 이름 &#x3D; new 컬렉션종류&lt;데이터타입&gt;();<br>예) HashSet<String> set &#x3D; new HashSet<String>();</p>
</li>
<li><p>객체 리스트</p>
<ul>
<li><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>구현클래스 : HashSet, TreeSet, LinkedHashSet<br>중학교때 배웠던 “집합”. 순서가 없다.  데이터의 중복을 허용하지 않는다.<br>Hash : 임의의 길이를 갖는 데이터를 고정된 길이의 데이터로 변환(매핑)하는 것<br> 해쉬는 유니크함을 보장하기 때문에 순회할 필요가 없다. -&gt; 검색을 매우 빠르게 할 수 있다.<br> 동일한 입력값에 대해서는 동일한 결과값(다이제스트)를 갖는다.<br> 이 다이제스트의 값을 index로 활용한다.<br>함수 : equals() : 들어있는 요소가 같은지 검사, hashCode(), removeAll(), contains(값), remove(값)   add(), size()<br>정의예 : HashSet<String> alphabetSet &#x3D; new HashSet&lt;&gt;();<br>    for(String spell: alphabet){<br>        alphabetSet.add(spell);<br>    }</p>
</li>
<li><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>구현클래스 :  ArrayList, LinkedList, Vector<br>배열의 최대 단점인 초기화 했을 때의 크기로 고정되는 것을 해결한 자료구조<br>순서가 있는 데이터의 집합으로 데이터의 중복을 허용<br>함수 : add(값),  addAll(리스트),   remove(인덱스),   clear(),   size()<br>  get(인덱스),   indexOf(값),   lastIndexOf(값)<br>반복문과 결합 :   향상된for문  for(자료형 이름 : 리스트)<br>             while(iterator.hasNext())<br>예제 : </p>
<pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// ArrayList 선언</span>
    ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> al <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// ArrayList에 데이터 입력</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        al<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 결과 출력</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>al<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//[1, 2, 3, 4, 5]</span>

    <span class="token comment" spellcheck="true">// 3번 데이터 제거</span>
    al<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 결과 출력</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>al<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1, 2, 3, 5]</span>

    <span class="token comment" spellcheck="true">// 하나씩 가져와서 결과 출력</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> al<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>al<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//1 2 3 5</span>
</code></pre>
</li>
<li><h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><p>구현클래스 :  LinkedList, PriorityQueue</p>
</li>
<li><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>구현클래스 : Hashtable, HashMap, TreeMap<br>키(Key), 값(Value)의 쌍으로 이루어진 데이터의 집합</p>
</li>
</ul>
</li>
<li><p>함수 리스트<br>add(), remove(), clear(), size()</p>
</li>
</ul>
<p>&#x2F;&#x2F; 직접 위의 함수들 구현해보는것 좋은 공부다.  private int[] nums,    private int current;</p>
<h2 id="String-문자열-클래스"><a href="#String-문자열-클래스" class="headerlink" title="String 문자열 클래스"></a>String 문자열 클래스</h2><p>이제야 눈에 보이는 스트링. 원시타입아니다.<br>자바에서 컬렉션으로 만들어 놓은 자료구조다.<br>charAt(), compareTo(), concat(), indexOf(), trim(), toLowerCase(), toUpperCase(), substring, length(), isEmpty(), contains() 문자의위치반환 없으면-1, matches(정규식) 등의 함수가 있다.<br>스트링은 값이 달라질때 새로운 객체를 만들어서 할당받는다.</p>
<p>&#x2F;&#x2F;자바에서 문자열1에서 문자열2를 포함한 갯수 찾기</p>
<pre class=" language-java"><code class="language-java">      <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCountInclude</span><span class="token punctuation">(</span>String str1<span class="token punctuation">,</span> String str2<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
          <span class="token keyword">boolean</span> include <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
          <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
          include <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment" spellcheck="true">//포함되었는지 참거짓 판단</span>
          <span class="token keyword">while</span><span class="token punctuation">(</span>include<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>	<span class="token comment" spellcheck="true">//포함되었다면</span>
             count<span class="token operator">++</span><span class="token punctuation">;</span>
             <span class="token keyword">int</span> where <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment" spellcheck="true">//시작하는 위치 파악</span>
             str1 <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>where<span class="token operator">+</span>str2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"str1 : "</span><span class="token operator">+</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//방금찾은거를 빼고 남은 문자열을 부모로 업데이트</span>
             <span class="token comment" spellcheck="true">//substring 함수는 인자가 하나면 해당위치부터 이후로 끝까지 자르는 함수</span>
             include <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
          <span class="token keyword">return</span> count<span class="token punctuation">;</span>
       <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="제네릭-Generic"><a href="#제네릭-Generic" class="headerlink" title="제네릭(Generic)"></a>제네릭(Generic)</h2><ul>
<li><p>뜻 :  포괄적인, 일반적인<br>Object 를 만들면 사용(저장, 로드)하기전에 형변환 작업을 해줘야하는 불편함이 존재한다.<br>범용 컬렉션의 장점과 특화된 클래스의 장점을 모두 겸비한 템플릿.</p>
</li>
<li><p>Java5에서 추가</p>
</li>
<li><p>컬렉션, 람다식, 스트림, NIO(New IO)등에서 널리 사용되므로 제네릭을 이해하지 못하면 API 문서를 정확히 이해할 수 없다.</p>
</li>
<li><p>목적<br>자료형을 일반화. 정의시가 아니라 인스턴스 생성시 자료형을 결정하도록 한다.<br>우리가 어떤 자료구조를 만들어서 배포하려고 할때 ‘여러 데이터타입을 지원하고 싶다.’  그러면 String에 대한 클래스, Integer에 대한 클래스 등등을 하나하나 타입별로 만들어줘야하나? 너무 비효율적이다.<br>제네릭은 이런 문제를 해결해준다.<br>그렇게 강조했던 메소드의 정의와 호출 다시한번 보자. 어떤 이름으로 넘어오든지 정의한 영역내에서는 이 이름으로 쓰겠다였지?<br>마찬가지로 제너릭이라는것은 어떤 데이터타입으로 넘어오든지 이 정의한 영역내에는 넘어온 그 데이터타입으로 쓰겠다 라고 하는것이다.<br>즉 데이터형을 정의시 명시하지 않고 호출할때 정할 수 있도록 일반화 한것이다.<br>클래스내부에서 지정하지 않고 외부에서 지정도록 한 것이다.<br>엄밀히 말하자면 컴파일때 해당 타입으로 캐스팅 하는 것이다.</p>
</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//일반</span>
List list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
String str <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//제네릭</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
String str <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 타입 변환을 하지 않습니다.</span>
</code></pre>
<ul>
<li><p>특징<br>보편적(암묵적)으로 매개변수의 타입으로는 아래의 이름을 쓴다.<br>  <E> : Element<br>  <K> : Key<br>  <N> : Number<br>  <T> : Type<br>  <V> : Value<br>특정범위내로 좁혀서 제한하고 싶다면 extends, super, ? 를 활용한다.<br>예를들어 <K super T>   이면 T타입의 조상만 가능하고 K로 쓰겠다는 말이다.</p>
</li>
<li><p>문법</p>
<ul>
<li>정의 : 클래스 또는 인터페이스 이름뒤에 &lt;타입파라미터&gt;<ul>
<li>생략하면 컴파일러가 제네릭 관련 문장에서 자료형의 이름을 추론한다. 이걸 다이아몬드 표시라고 한다.</li>
<li>타입 파라미터로 명시할수 있는것은 참조타입만 가능하다.</li>
<li>여러개의 타입변수는 쉼표로 구분하여 명시한다.</li>
</ul>
</li>
<li>사용 : 본문에서 그 이름을 데이터타입처럼 사용하면된다.</li>
</ul>
</li>
<li><p>예</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 클래스 뒤에 &lt;T> 타입 파라미터를 명시했기 때문에 변수의 타입으로 사용 가능합니다.</span>
  <span class="token keyword">private</span> T t<span class="token punctuation">;</span>
  <span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>t <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
</li>
<li><p>장점</p>
</li>
</ul>
<ol>
<li>런타임에 잘못된 타입이 들어올 수 있는것을 컴파일 단계에서 방지한다.</li>
<li>반환값에 대한 타입 변환(캐스팅) 및 타입검사에 들어가는 노력 줄어듬</li>
<li>코드의 재사용성이 높아진다.</li>
</ol>
<h2 id="중요한-것"><a href="#중요한-것" class="headerlink" title="중요한 것"></a>중요한 것</h2><p>데이터타입(원시형, 참조형)<br>객체, 클래스, 인스턴스<br>생성자<br>추상클래스, 인터페이스<br>오버라이드, 오버로드<br>배열, 리스트</p>
<h2 id="람다식-Lamda-Expression"><a href="#람다식-Lamda-Expression" class="headerlink" title="람다식(Lamda Expression)"></a>람다식(Lamda Expression)</h2><blockquote>
<p>자바8에 함수적 프로그래밍 기법으로 도입됨. 람다가 포함되면서 자바가 완전해졌다고 말하는 이가 있을정도.<br>익명함수를 생성하기 위한 식<br>y &#x3D; f(x) 형태   를 (타입 매개변수) -&gt; { 실행문 }   으로 정의<br>좋든 싫든 자바의 람다식은 선택이 아닌 필수가 되었다.<br>장점 : 1. 코드가 매우 간결해진다.<br>        2. 인스턴스 생성안하고 기능하나만 필요할때<br>        3. 함수 이름을 생각하지 않아도 됨<br>        4. 컬렉션요소를 매핑해서 쉽게 집계할 수 있다.<br>단점 : 가독성이 안좋아진다.<br>    함수이름이 없기 때문에 stacktrace보고 디버깅하기 어렵다.<br>    이 함수가 있음을 인식하기가 어렵다.<br>결론 : 저런 단점들때문에 고급개발자는 람다식 쓰지말라고도 하는사람 많다.<br>    본문이 3줄안에 끝나고 단 한번만 쓰임을 보장할 수 있고 행동이 명확할 때만 제한적으로 사용.<br>문법 : 인풋데이터 -&gt; 함수본문<br>예  :1. 줄임이 없는 예<br>  (String s) -&gt; { System.out.println(s); }</p>
</blockquote>
<ol start="2">
<li><p>매개변수가 하나일때 괄호생략. 본문이 하나일때 중괄호와 세미콜론 생략<br>   s -&gt; System.out.println(s)<br>   (a,b) -&gt; a+b</p>
</li>
<li><p>제네릭으로 사용한 예<br>  Calculate<Integer> ci &#x3D; (a,b) -&gt; a+b;<br>  System.out.println(ci.cal(4,3));</p>
</li>
</ol>
<h2 id="ERD"><a href="#ERD" class="headerlink" title="ERD"></a>ERD</h2><p>Entity Realationship Diagram<br>개체 관계도(그림)</p>
<h2 id="툴"><a href="#툴" class="headerlink" title="툴"></a>툴</h2><ul>
<li>erwin : 유료 (실무. 월 천만원)</li>
<li>erdcloud.com : (오른쪽에 광고가 있지만 무료로 사용할 수 있음)<br>노란색은 pk추가, 파란색은 기본컬럼 추가<br>상단아이콘은 테이블복사, 테이블색, 테이블정보, 삭제<br>자동으로 쿼리를 만들어주는데 부모가 없는데 자식을 먼저 생성하는 등 순서가 안맞는 경우, 해당 RDBMS에서 지원하지 않는 함수를 쓰거나 등의 문제가 있어서 한방에 정상 실행안되므로 조금 수정해줘야한다.<br>fk가 있는놈들을 나의 pk지정할때 하나씩 분리되어있는데, 로 이어줘야한다.<br>1064 SYNTAX ERROR 뜨는데 만들어진 쿼리에 첫번째 CREATE 문에 이상한 스페이스가 숨어있다.</li>
</ul>
<pre><code>    &lt;details&gt;
    &lt;summary&gt;여러개 테이블에서 foreign키 설정하는법&lt;/summary&gt;
    &lt;div markdown=&quot;1&quot;&gt;
    ALTER TABLE `brand_coffee`
    ADD CONSTRAINT `FK_brand_TO_brand_coffee_1`
    FOREIGN KEY (
       `brand_id`
    )
    REFERENCES `brand` (
       `brand_id`
    )
    ,
    ADD CONSTRAINT `FK_brand_TO_brand_coffee_2`
    FOREIGN KEY (
       `class_id`
    )
    REFERENCES `coffee` (
       `class_id`
    );


    insert into brand
    (brand_id, brand_name, brand_content, brand_logo)
    values
    (&quot;starbucks&quot;, &quot;스타벅스&quot;, &quot;세계최대의 커피브랜드&quot;, &quot;스타벅스 로고&quot;);

    insert into coffee
    ( class_id, class_name, class_content, class_img)
    values
    (&quot;americano&quot;, &quot;아메리카노&quot;, &quot;커피의 기본&quot;, &quot;아메리카노&quot;);


    insert into brand_coffee
    (brand_id, class_id)
    values
    (&quot;starbucks&quot;, &quot;americano&quot;);
    &lt;/div&gt;
    &lt;/details&gt;
</code></pre>
<ul>
<li>draw.io</li>
<li>Exerd</li>
</ul>
<h2 id="좋은-사이트"><a href="#좋은-사이트" class="headerlink" title="좋은 사이트"></a>좋은 사이트</h2><ul>
<li><a target="_blank" rel="noopener" href="https://helloblog.net/%EC%82%AC%EC%9A%A9%EC%9E%90-%EA%B6%8C%ED%95%9C-db-%EB%AA%A8%EB%8D%B8%EB%A7%81/">https://helloblog.net/%EC%82%AC%EC%9A%A9%EC%9E%90-%EA%B6%8C%ED%95%9C-db-%EB%AA%A8%EB%8D%B8%EB%A7%81/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PL9gStYgm-otNZQpj2lQsOSRuiwwtEftiE">엔코아 이화식</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PLuHgQVnccGMDF6rHsY9qMuJMd295Yk4sa">생활코딩 관계형데이터베이스</a></li>
<li><a target="_blank" rel="noopener" href="https://www.erdcloud.com/d/PK2Ae7d4asTRqHpHx">OKKY ERD</a></li>
</ul>
<h2 id="좋은설계"><a href="#좋은설계" class="headerlink" title="좋은설계"></a>좋은설계</h2><ul>
<li>높은 응집도(cohesion). 낮은 결합도(coupling) &#x3D;&gt; 업무의 변화에 최대한 영향을 적게받는 유연한 시스템<br>좋은 설계 : 변경사항이 들어오면 변경사항만 바꾸면 되는 시스템.<br>    키보드만 고장나면 키보드만 갈아끼우면 되는시스템<br>    스페이스바만 고장나면 스페이스바만 갈아끼우면 되는 키보드.<br>    스페이스바가 고장나면 스페이스바만 갈아끼울수있는 키보드<br>안좋은 설계 : 변경사항을 처리하기위해 기존의 잘되던것들도 뜯어 고쳐야 하는 시스템.<br>    키보드만 고장나면 컴퓨터를 교체해야되는 되는시스템<br>    스페이바가 고장나면 키보드 전체를 갈아야되는 키보드</li>
</ul>
<h2 id="모델링"><a href="#모델링" class="headerlink" title="모델링"></a>모델링</h2><ul>
<li><p>정의<br>복잡한 현실에서 우리가 관리할 정보를 정확히 규명하여 단순명료하게 핵심만 뽑아서 만들어내는 것.<br>모델링이 아무리 복잡해도 현실이 훨씬 복잡하다.<br>일반인이 아파트 설계도를 보면 복잡하다고 하지만 아파트 공사짓는 사람이 설계도를 보면 빠진게 많다고 불평할거다. 엔드유저는 매우 간단한 도면을 받는다.<br>프로그래머는 아파트를 사는 사람이 아니라 짓는사람이다.<br>초갓집을 지을때는 간단한 평면도 또는 설계도가 없이도 집을 지을수 있다.<br>그러나 대형빌딩을 지을때 설계도는 없어서는 안되고 웬만한 설계도로는 집을 지을수 없다.<br>창문이 어디에 있다 정도가 아니고 mm단위로 너비, 높이, 두께, 재질, 설치위치 등이 다 명시되어 있어야한다.</p>
</li>
<li><p>‘어떤 모델을 만들어야겠다’ 라고 미리 생각하지 않는다. 모델링은 결과의 툴이 아니라 과정의 툴이다.<br>유능한 수사관은 범인이 누구인지 알고 잡지 않는다. 현장에서 하나씩 알아가면서 완성해나가는것이지 알고나서 그리는것이 아니다. 즉, 업무를 몰라도 할 수 있다는 말이다. 어느누구도 그 회사의 업무를 다 알수없다.<br>백지상태로 가서 해당업무를 아는 담당자에게 묻고 확인해가며 이끌어내는것이다.</p>
</li>
<li><p>객관화 되어야 한다. 누구도 꼼짝 못할 논리가 있어야 한다.</p>
</li>
<li><p>판단력이 있어야한다. 맞고 틀리는게 아니다. 최선의 답을 찾아나가는 과정이다.<br>모델링적으로는 90점짜린데 개발까지 감안하면 10점짜리일수 있다.<br>데이터베이스를 모르면 그 판단을 못한다.</p>
</li>
<li><p>방법을 안다고 해서 실제로 모델링을 할 수 있게 되는것이 아니다. 그래서 어렵다.</p>
</li>
<li><p>스포츠 선수는 선수로서의 기간은 짧고 이후에 코치나 감독이 된다. 모델러는 프로그래머의 노후에 가기 좋은 길이다.<br>모델러는 오케스트라의 지휘자다. 아무소리도 안내지만 모든 소리를 조율한다.</p>
</li>
<li><p>데이터가 더러우면 프로그래머가 고생한다. 그걸 다 프로그램단에서 제어해줘야 되기 때문에. 데이터가 단순하고 깨끗하면 초급도 일할수 있고 일을 시키기도 쉬워진다.</p>
</li>
<li><p>RDB가 생기기전에는 어떤 설계를 하더라도 속도가 비슷비슷했다. 그러나 RDB는 설계에따라서 속도가 100배넘게도 차이난다. 3일 걸리던게 3초만에 끝날 수 있다.</p>
</li>
<li><p>현재만 봐서는 안된다. 요구는 계속 바뀌거나 생겨날것이고 직원과 회사는 변화고 사회적인 상황도 변한다. 그것들을 생각해서 설계해야한다.</p>
</li>
<li><p>정보는 연결되어있어야 한다. 어디에도 연결되지 않고 뚝 떨어진 정보는 없어야 한다.</p>
</li>
<li><p>데이터는 기업의 자산이다. 그런데 이력관리가 안되게 설계해놓은곳이 너무 많다.<br>예를들어 부서를 옮겼으면 현재부서만 저장되는것이 아니라 이대까지 언제 어디로 옮겼는지 내역이 저장되어 있어야한다.</p>
</li>
<li><h3 id="목적"><a href="#목적" class="headerlink" title="목적"></a>목적</h3><ul>
<li>업무내용의 정확한 분석</li>
<li>실제 데이터베이스를 생성하는 기초</li>
</ul>
</li>
<li><h3 id="방법"><a href="#방법" class="headerlink" title="방법"></a>방법</h3><ol>
<li><p>기능모델링 먼저<br>가장 일반적인 방법<br>기능에 따른 데이터의 흐름인 DFD(Data Flow Diagram)를 보고 데이터모델설계.<br>DFD는 추상적, 흐름적, 계층적이다.<br>이 방법의 문제는 기능에 따라 데이터가 종속된다는 점이다.<br>기능이 바뀌면 모델이 바뀌게 된다.<br>급여와 사원의 데이터 구조는 유지한채로 주는 방법이 바뀌어야 되는데 주는 방법이 바뀌게 되면 데이터 구조가 바뀌게 된다.</p>
</li>
<li><p>병렬로 동시 진행<br>주로 대형프로젝트에서 사용<br>반드시 다수의 전문가가 있을때 사용해야 한다.<br>전문가는 자기일만 잘하는것이 아니라 자기일에 영향을 미칠 요소들을 다 관리한다.<br>그래서 각 분야의 전문가들이 긴밀하게 연결되어 타분야의 이상요소를 빨리 감지하여야 한다.</p>
</li>
<li><p>데이터모델링 먼저<br>객관적, 구체적, 흐름없음<br>업무를 잘 모르는 시점에 할 수 있어야 하기 때문에 전문적인 모델러가 필요하다.<br>가장 이상적인 방법이다.</p>
</li>
</ol>
</li>
</ul>
<h3 id="중요한-사항들"><a href="#중요한-사항들" class="headerlink" title="중요한 사항들"></a>중요한 사항들</h3><ul>
<li><strong>데이터 모델에는 시간개념이 없다.</strong> 프로세스가 아니다. 흐름이 있는게 아니다.</li>
<li>어떤 사원이 월급을 받았든 안받았든 상관이 없다. 사원과 월급과의 관계만 정해주는거다.</li>
<li>예외에 계속 집중하지 마라. 언젠가는 그얘기를 할때가 온다. 그때해야한다.</li>
<li>모델링은 무조건 <strong>1촌관계만 그려준다.</strong> 삼촌사촌 등은 명시하지 않아도 관계에 의해서 저절로 정해진다.</li>
<li>풍경을 2시간동안 열심히 머릿속에 저장하고 집에와서 그리면 그게 풍경화인가?<br>아무리 업무 설명을 잘듣고 정리하고 와도 집에와서 그걸 그리면 그게 뭔가<br>현장에서 실제 업무속에 들어가서 실시간 피드백을 들으면서 모델링을 해야한다.</li>
<li>주관이 들어가지 않고 있는 그대로를 찍는 사진이 있고, 주관적인 느낌을 담아 작품을 만드는 사진이 있다.</li>
</ul>
<p><strong>모델러는 작가다. 모델은 작품이다.</strong> 지금의 상황 그대로를 그려내는일을 하는것이 아니다.</p>
<ul>
<li>업무가 내 한계를 벗어난다면 한층을 한번에 못올라가서 계단을 놓듯이, 내가 감당할수있는 단위로 잘게잘게 쪼개서 단위별로 완성하고 합치면 된다. 그러면 아무리 높은곳이라도 올라갈 수 있다.</li>
</ul>
<h2 id="팁"><a href="#팁" class="headerlink" title="팁"></a>팁</h2><ul>
<li>4개컬럼은 거의 모든 테이블에 들어간다.<br>(생성일, 생성자, 수정일, 수정자)</li>
<li>계산으로 가져올수있는 테이블은 컬럼으로 만들지 않는다.</li>
<li>날짜 이런식으로 말고 무슨날짜인지 명확하게 인지되도록.</li>
</ul>
<h2 id="무결성-제약조건-5가지"><a href="#무결성-제약조건-5가지" class="headerlink" title="무결성 제약조건 5가지"></a>무결성 제약조건 5가지</h2><p>컬럼에 제약조건을 5가지 종류로 걸 수 있다.</p>
<ul>
<li>NOT Null   &#x3D; 빈값이 들어가선 안된다.</li>
<li>unique    &#x3D; 해당테이블에서 유일하게 존재해야함. 단, NULL은 여러개 있을수있음</li>
<li>PRIMARY Key(기본키)  &#x3D; unique &amp;&amp; not null. 한행을 식별하기위한 기준<ul>
<li>PK는 유니크와 낫널이다. (O)    유니크와 낫널이면 PK다.(X)</li>
</ul>
</li>
<li>FOREIGN Key(외래키)  &#x3D; 참조하는 테이블(부모)에 존재하는 값들만 사용해야 함<ul>
<li>반드시 존재하는 값은 PK이기 때문에 다른 PK를 받아온다고 생각하면 된다.</li>
</ul>
</li>
<li>CHECK   &#x3D; 조건에 부합하는 데이터만 입력 가능</li>
</ul>
<h2 id="Entity-엔티티"><a href="#Entity-엔티티" class="headerlink" title="Entity (엔티티)"></a>Entity (엔티티)</h2><ul>
<li><p>엔티티는 <strong>집합</strong>이다. 나중에 테이블로 변경된다.<br>(중요)메인엔티티는 <strong>개체</strong>든 <strong>행위</strong>든 하나의 순수한 집합이여야 한다.<br>집합은 정의 가능한 사물 또는 개념을 의미한다. 그러나 집합이라고 다 엔티티는 아니다.<br>예를 들어 ‘납입자’는   납입이라는 엔티티와 사람이라는 엔티티가 연결된 관계다.  ‘청구서’ 이런거 마찬가지겠지.</p>
</li>
<li><p>엔티티가 잘 못뽑는다면 정의가 잘 안됐기 때문에 그런것이다.</p>
</li>
<li><p>엔티티 이름 짓기 매우 중요하다. 누가보더라도 어떤 집합인지 명확하게 느껴지도록.</p>
</li>
<li><h3 id="순서"><a href="#순서" class="headerlink" title="순서"></a>순서</h3><p><strong>후보 엔티티</strong> 뽑기 -&gt; <strong>키 엔티티</strong>(부모가 없이 자기 스스로 탄생가능) -&gt; <strong>메인엔티티</strong>(업무의 중심) -&gt; <strong>자손엔티티</strong></p>
</li>
<li><p>프로그램과 화면에서 가장 많이 다루게될것은 자손엔티티가 될것이다. 근간이 되는 데이터는 잘 변하지 않는다.</p>
</li>
<li><p>디비설계는 이 모델링을 가지고 데이터베이스의 테이블 형태로 변환하는 비교적 기계적인 일이다.</p>
</li>
<li><h3 id="엔티티인지-검증-판별-규칙"><a href="#엔티티인지-검증-판별-규칙" class="headerlink" title="엔티티인지 검증(판별 규칙)"></a>엔티티인지 검증(판별 규칙)</h3></li>
</ul>
<ol>
<li>동질성을 가진 집합인지(정의한 집합 테두리에 포함되는지)</li>
<li>독립성을 가진 집합인지(부분집합이 아니여야하고 교집합이 없어야 한다.)  엔티티끼리 교집합이 생긴다면 문제가 생긴거다. 예) 가입자, 납입자</li>
<li>가로*세로로 면적이 되어야한다.<br>가로(속성)가 2개이상이고, 세로(데이터)가 2개 이상이어야 한다.</li>
<li>행위엔티티와 개체 엔티티를 합친 엔티티는 분리해야된다.</li>
<li>최소한 하나이상의 다른 엔티티와의 관계를 가지는지</li>
<li>식별자가 있어야한다.</li>
</ol>
<h2 id="기본키"><a href="#기본키" class="headerlink" title="기본키"></a>기본키</h2><ul>
<li><strong>한 테이블의 유일함을 결정짓는 속성</strong></li>
<li>한테이블의 기본키는 하나의 컬럼에만 지정할수있다? 맞을까? 틀릴까?</li>
<li>“테이블은 오직 하나의 기본키를 가질 수 있다.” 이건 정확한 정의다.<br>그런데 그 말을 “테이블의 PK는 오직 하나의 컬럼으로만 설정할수있다” 라고 잘못이해하는 경우가 대부분이다.<br>기본키는 여러개의 컬럼의 복합키로 구성될수 있다.<br>&#96;&#96;&#96;<br>예를들어 ‘판매실적’을 저장하는 테이블이 있다.<br>어떤 판매실적을 하나의 행으로 다룰건지 그 목적에 따라 기본키가 달라지진다.<br>총 컬럼은 날짜, 영업사원(판매자), 판매제품, 판매처, 판매처직원, 판매제품의하나당가격, 판매제품의 수량  이 있을때<br>우리는 누가, 언제, 어디에, 어떤 제품을 팔았는지에 대한 판매실적을 담고 싶다고 하자.</li>
</ul>
<p>2021-08-18-14시, 배성원, 리모콘, 흥국생명, 홍길동, 50만원, 100개<br>PK는 뭘로 지정해야할까?<br>여기서 PK가 하나가 된다면 어떻게 될까? 예를들어 영업사원이 PK이면? 판매사원별로 판매실적을 저장하는 테이블이 되는것이다.<br>한사람이 한날짜에 한번씩만 기록되도록 날짜와 사원번호를 넣으면? 그 사원은 판매실적을 한날짜에 한번밖에 저장 못하게 된다.<br>마찬가지 원리로<br>  같은날짜에 한사람이 하나밖에 등록하지 못하면 안되니까 판매처 추가<br>  같은날짜에 한사람이 한판매처에 한번밖에 등록하지 못하면 안되니까 제품 추가.<br>결국 날짜, 사원번호, 판매처, 제품명 4개의 조합이 복합키가 되어야 한다.</p>
<p>&#96;&#96;&#96;<br>후보키는 유일성과 최소성을 만족시켜야함</p>
<h2 id="인조키"><a href="#인조키" class="headerlink" title="인조키"></a>인조키</h2><p>마땅한 자연키가 없거나 복합키가 너무 많을때 편의를 위해 자연적이지 않고 인공적으로 부여한 키를 말한다.<br>PK가 너무많은 컬럼으로 구성되면 조인할때 너무 불편하다.<br>(조인할때는 유일한 식별을 위해 식별되는 모든컬럼을 WHERE조건에 걸어줘야 되기 때문에.)</p>
<p>예) 글번호, 주민등록번호</p>
<ul>
<li>※주민등록번호를 회원테이블의 pk로 잡으면 생기는 문제<br>갑자기 주민등록번호를 보안정책에 의해 별도로 암호화해서 보관해야합니다? 하면 피똥쌈.<br>여기저기서 유저 참조할때 FK로 사용했다? 프로그램 전체를 다 갈아엎어야됨.</li>
</ul>
<h2 id="참조키"><a href="#참조키" class="headerlink" title="참조키"></a>참조키</h2><pre><code>- FK가 정의된 테이블이 자식 테이블이다.
- 참조되는 테이블은 부모 테이블이다.
- 부모테이블은 미리 생성되어 있어야 한다.
- 부모테이블에 존재하는 값만 입력가능하도록 하는 제약조건이다.
- 부모테이블을 참조하는 자식데이터가 있으면 부모 데이터를 지울수 없다.
    - ON DELETE CASCADE : 부모의 행이 지워지면 자식의 행도 같이 지워진다.
    - ON DELETE SET NULL : 부모의 행이 지워지면 자식의 행은 NULL이 된다.
</code></pre>
<ul>
<li>데이터타입이 반드시 일치해야한다.</li>
<li>참조되는 컬럼은 PK 또는 UNIQUE여야 한다.</li>
<li>비식별관계로 FK가 걸리면 ERD상에는 보이지만 실제 제약조건으로는 안걸린다.</li>
</ul>
<h2 id="모델링의-순서"><a href="#모델링의-순서" class="headerlink" title="모델링의 순서"></a>모델링의 순서</h2><ul>
<li><p>요구사항 분석 -&gt; 개념적 모델링(주제별 핵심엔티티, 관계) -&gt; 논리적 모델링(정규화. 모델링의 핵심) -&gt; 물리적 모델(실제컬럼명, 데이터타입, 길이, 실제저장공간, 분산, 인덱스 설계, 성능최적화) -&gt; DB스키마 구현후 스크립트 파일로 보관 -&gt; 테스트데이터 입력</p>
</li>
<li><p>논리적 모델링까지는 어떤 데이터베이스를 쓸건지는 전혀 생각하지 않는다.<br><a target="_blank" rel="noopener" href="https://rutgo-letsgo.tistory.com/138">좋은예제</a></p>
</li>
<li><p>실무에서 가장 요긴하게 사용될 논리모델과 주제영역은 완전하게 연결되는것이 이상적.</p>
</li>
<li><p>주제영역이란 기업이 사용하는 데이터의 최상위 집합. 예를들어 인사, 자재, 판매, 재무 등</p>
</li>
<li><p>논리적 모델링이 전체 모델링 과정중 가장 오랜시간이 소요된다.</p>
</li>
<li><p>논리모델링에서는 속성명을 한글로 표현한다.</p>
</li>
<li><p>논리 모델링에서 물리 모델링으로 넘어오면서 고려하는 작업<br>-Super&#x2F;Sub 관계의 엔티티를 몇 개의 테이블로 만들 것인가<br>-배타적(Arc) 관계 엔티티의 외부키(Foreign Key)를 몇 개로 할 것인가<br>-성능 향상을 위해 테이블을 추가해야 할 것인가 혹은 통합해야 할 것인가<br>-통계 작업을 위해 합계(Summary) 테이블 같은 임시성 테이블을 몇 개로 할 것이며, 유일키를 무 엇으로 할 것인가<br>-테이블의 칼럼을 다른 테이블에 중복할 것인가, 중복한다면 어떤 애플리케이션이 관련되어 있는 가, 인덱스의 설정, 스냅샷(Snapshot) 또는 뷰(View) 등의 객체가 필요한가<br>-분산 환경에서 테이블을 중복할 것인가, 중앙에 필요한 테이블을 따로 가져갈 것인가<br>-데이터가 분산 환경에서 이동 시 문제를 어떻게 해결할 것인가</p>
</li>
<li><p>속성의 추가 VS 엔티티의 추가<br>우리가 했던거 기능5를 넘어서는 기능이 추가되면 계속 컬럼을 추가하는 작업을 해줘야했잖아. (배경을 모른다면 색깔로 생각하자.)<br>이것을 모델1이라고 하자.<br>그래서 기능테이블을 따로 뺐는데 이걸 모델2라고 하자.<br>모델1에서 모델2로 진화한것이 아니다. 어느모델이 더 좋고 나쁜것이 아니라 우리 상황에 더 적합한것이 좋은거다.<br>모델1은 직관적이다.<br>모델2는 추상화되었다. 확장이 쉽다.</p>
</li>
</ul>
<h2 id="데이터-설계"><a href="#데이터-설계" class="headerlink" title="데이터 설계"></a>데이터 설계</h2><p>데이터 모델을 그릴때는 ‘행위(동사)’, ‘대상(목적어)’, ‘주체(주어)’를 구분하라.<br>예) 행위에 의한 관계 : 강사, 강의한다, 수강생.<br>예) 존재에 의한 관계 : 사원, 소속된다, 부서<br>DB모델링이라는것은 데이터의 관계를 눈으로 볼수있도록 모델링하는것.</p>
<h2 id="ER모델"><a href="#ER모델" class="headerlink" title="ER모델"></a>ER모델</h2><p>  Entity Relationship Model.    ERD의 D는 Diagram<br>  요구사항으로부터 얻어낸 정보들을 개체, 애트리뷰트, 관계성으로 기술하는 개념적 데이터 모델.</p>
<p>  학생 한명은 개체(Entity),  네모(□)로 표현. 후에 테이블이 된다.<br>  개체가 갖는 속성(Attribute)는 원(○)으로 표현. 후에 컬럼이 된다.<br>  개체간의 관계(Relation)는 마름모(◇)로 표현. 후에 pk와 fk가 된다.</p>
<p>  바커표기법가 IE표기법이있다. 김이사님이 쓰는건 IE표기법.<br>  바커표기법은 한쪽에서 나가고, 다른쪽에서 나간걸 합친것.</p>
<h2 id="관계"><a href="#관계" class="headerlink" title="관계"></a><a target="_blank" rel="noopener" href="http://wiki.gurubee.net/pages/viewpage.action?pageId=26743462">관계</a></h2><p>  IE표기법을 기준으로 설명.<br>  관계는 무조건 그 행을 유니크하게 구분할 수 있어야 하기 때문에 조인할때 한쪽의 테이블 기본키에 해당하는 컬럼을 모두 가져와야 한다.<br>  관계는 존재에 의한것인가 행위에 의한것인가 2가지로 구분된다.<br>  관계명(Membership), 관계차수(Cardinality), 관계선택사양(Optionality) 3개를 표기해줘야한다.<br>  애매한 동사를 피하고 현재형으로 표현한다.</p>
<h2 id="Cardinality-카디널리티-관계차수-Degree"><a href="#Cardinality-카디널리티-관계차수-Degree" class="headerlink" title="Cardinality(카디널리티). 관계차수. Degree"></a>Cardinality(카디널리티). 관계차수. Degree</h2><ul>
<li>테이블이 몇대 몇으로 연결되어 있느냐 따지는 것</li>
<li>목적어 쪽에 부호가 붙는다</li>
<li>3가지 1:M,   M:M,   1:1</li>
<li>1은 세로선, N은 까치발로 표현</li>
<li>예) 1:1 담임, 교실,    1:N 글-댓글,  부서-사원    N:M 주문, 제품</li>
<li>1:M관계가 90%. 수평관계보다 수직관계가 많다.<br>1:N 관계는 자식테이블에 FK로 집어넣어 관계를 표현한다.</li>
<li>M:M관계는 모델링이 진행되는 과정의 덜풀린것이다. M:M은 최종물리모델에서는 구현될 수 없기 때문에 모델링이 끝나면 M:M관계 없어야한다. 다대다 관계를 실제로 구현하기 위해선 각 테이블의 PK를 FK로 참조하고 있는 <strong>연결테이블</strong>(<strong>관계테이블</strong>, <strong>관계해소테이블</strong>)을 사용해야 한다.<br>  M:M관계에는 업무가 녹아있는 거다. 업무의 깊이가 깊으면 M:M을 풀면 계속해서 M:M이 나온다.<br>  M:M을 관계에서 관계엔티티로 언제 풀거냐 하는걸 잘 결정해야한다.<br>  )</li>
</ul>
<h2 id="Optionality"><a href="#Optionality" class="headerlink" title="Optionality"></a>Optionality</h2><p>연관되는 엔티티의 값이 반드시 존재해야하는지(Mandatory), 존재하지 않아도 되는지(Optional)를 의미<br>없어도되면 Optional의 동그라미로 표현</p>
<p>아래그램과 같이 양쪽이 선택이면 의무적인 관계가 없는것과 마찬가지이지만 연관관계는 존재하므로 관계선을 삭제하는것은 바람직하지 않다.<br>상위엔티티쪽의 옵셔널리티가 필수가 되는것이 좋다.</p>
<p>대부분의 경우 1:n관계에서 n쪽에는 optional이 붙게 된다.이는 물리적 구현이 어려워서이기도 한다.</p>
<p>관계는 Cardinality, Selectivity, 방향 이 세 가지 요소로 구성된다. 기호가 어디에 붙냐가 정말정말 헷갈리는데 <strong>목적어 방향</strong>에 붙는다고 생각하자.</p>
<p>주어쪽은 하나(One) 또는 각(Each)로 읽는다.<br>목적어쪽은 아래와같다.<br>( 목적어쪽에 선 하나 : 하나의 A는 하나의 B로 구성되어있다,<br>  목적어쪽에 삼발이 : 하나의 A는 N개의 B로 구성되어있다.<br>  목적어 쪽에 허수아비 : 하나의 A는 0개 또는 1개의 B로 구성되어있다,<br>  목적어쪽에 O에삼발이 : 하나의 A는 0개 또는 N개의 B로 구성되어있다.<br>또 쉽게 알아낸것은 수많은 자식들이 당신만 바라보고있어요. n:1관계. 1쪽이 부모. 많은놈이 1쪽을 참조한다.)</p>
<pre><code>예) 부서는 사원을 여러명 가진다. 사원쪽에 까치발.
   사원은 하나의 부서에만 소속될수있으면 부서쪽에 한발.
   사원이 여러 부서에 소속될수 있으면 부서쪽에 까치발.
   사원은 한개의 부서에 반드시 소속되어야 하면 선하나.
</code></pre>
<h2 id="실제-구현"><a href="#실제-구현" class="headerlink" title="실제 구현"></a>실제 구현</h2><p>관계는 PK와 FK로 구현된다.<br>1:N은 볼것도없이 1쪽의 PK를 N쪽이 FK로 가져가면 된다.<br>1:1은 누구에게 FK를 줄지 애매하다. 의미를 뜯어봐야한다. (회원, 휴면회원 테이블)<br>N:M은 어디에 PK, FK를 주더라도 모순이 생기기 때문에 즉, 실제로 불가능하기 때문에 중재자가 필요하다.</p>
<h3 id="설계의-정합성은-형식으로-판단한다"><a href="#설계의-정합성은-형식으로-판단한다" class="headerlink" title="설계의 정합성은 형식으로 판단한다."></a>설계의 정합성은 형식으로 판단한다.</h3><p>내용(데이터)는 이해를 돕기위한 참조일뿐.<br>그래서 설계를 잘하려면 업무를 몰라야 한다라는 말이 있다. 추상화된 형식으로 확장성 높도록.<br>더이상 추가할게 없는것이 아니라 더이상 제거할것이 없을때 설계가 완성된다.</p>
<h3 id="설계는-제약의-표현이다"><a href="#설계는-제약의-표현이다" class="headerlink" title="설계는 제약의 표현이다."></a>설계는 제약의 표현이다.</h3><p>제약하지 않은건 다 가능하다고 봐야한다. 고객이 거기에 0 안들어와요, null 안들어와요. 이런거 믿지말고 시스템적으로 제약을 해야한다. 반드시. 안그럼 뒤통수 세게 맞는다.</p>
<h2 id="식별관계와-비식별관계-실선과-점선"><a href="#식별관계와-비식별관계-실선과-점선" class="headerlink" title="식별관계와 비식별관계(실선과 점선)"></a>식별관계와 비식별관계(실선과 점선)</h2><ul>
<li><h3 id="식별관계-x3D-실선"><a href="#식별관계-x3D-실선" class="headerlink" title="식별관계 &#x3D; ### 실선"></a>식별관계 &#x3D; ### 실선</h3><p>Identifying Relationship. 부모가 없으면 존재할수 없는 관계.<br>데이터의 정합성(자식테이블에 데이터가 있으면 부모에 반드시 있음을 보장)<br>키상속. 부모의 pk가 자식의 pk로 들어오는 경우.양쪽의 키가 모두 기본키일때.<br>   반드시 부모엔터티가 있어야 자기자신의 엔터티가 생긴다.<br>   키를 상속했다는 말은 너의 모든 데이터를 내가 빠짐없이 사용하겠다는 말.<br>  부모데이터가 자식어딘가에서 참조되고 있다면 못지운다.<br>  자식데이터는 지울수있다.<br>요구사항이 변경되었을경우 구조변경이 어렵다.<br>1:m관계가 계속 식별로 연결된다면 자식으로 갈수록 pk의 갯수가 계속 늘어나는 문제가 있다.</p>
</li>
<li><h3 id="비식별관계-x3D-점선"><a href="#비식별관계-x3D-점선" class="headerlink" title="비식별관계 &#x3D; ### 점선"></a>비식별관계 &#x3D; ### 점선</h3><p>참조하되 기본키가 아닌 일반키로 참조.<br>변경되는 요구사항을 유동적으로 수용할 수 있다.<br>부모데이터와 독립적인 자식 데이터를 생성할 수 있다.<br>데이터 정합성을 지키기위해 별도의 비지니스 로직이 필요하다.<br>  (부모의 pk만 가져오는것이지, 부모의 일반컬럼들을 자식엔터티로 내려받는다는 보증이 안되었기 때문에 정확한 정보를 위해서는 안해도되는 조인을 해야된다.)<br>키상속 아님.부모의 pk가 자식의 일반속성이 되는 경우. 한쪽만 기본키일대.<br>   부모가 없어도 자식이 생길수있다. 자식은 남기고 부모가 먼저 소멸될 수 있다.<br>  부모데이터, 자식데이터 제각각 지울수있다.<br>(즉, 데이터 무결성을 보장하지 않으며 자식데이터가 존재해도 부모데이터가 없을수있다는 말)</p>
</li>
<li><p>식별관계와 비식별관계중 무엇을 선택해서 연결하는지는 높은 내공을 요구한다.<br>기본적으로는 다음조건에 해당할 경우 비식별자관계로 만들면된다.<br>약한관계, 자식테이블의 독립적pk가 필요, sql이 너무복잡하게 만들어져서 개발생산성이 저하됨.<br>ERD클라우드에서 비식별관계는 실제 물리적으로는 구현되지 않는다. 설계를 보고 화면에서 콤보박스를 만들든가 하는식으로 해결. 반드시 정합성을 유지해야하는 경우만 식별관계를 쓰고 웬만하면 비식별로 설계하는 것을 권장.</p>
</li>
<li><p>선택적 비식별관계와 필수적 비식별관계<br>NULL이면 선택적 비식별관계<br>NOTNULL이면 필수적 비식별관계<br>선택적 비식별관계는 NULL을 허용하므로 조인할때 외부조인을 사용해야 한다.<br>필수적 비식별관계는 NOT NULL로 항상 관계가 있음을 보장하기 때문에 내부조인만 사용해도된다.</p>
<p>&#x3D;&gt; 필수적 비식별관계를 하느냐 식별관계를 하느냐의 판단 기준</p>
<ol>
<li>식별관계로 묶다보면 자식테이블의 기본키 컬럼이 점점 늘어난다.<br>결국 조인할때 SQL이 복잡해지고 기본키 인덱스가 불필요하게 커질수 있다.<br>자연키컬럼의 조합일경우 식별관계가 좋고<br>인조키(대리키)일경우 필수적 비식별관계가 좋다. 비지니스 요구사항은 시간이 지남에 따라 변하기 때문.</li>
<li>데이터의 정합성이 중요할경우 식별관계<br>예) 수강내역은 학생이 없다면 존재의 의미가 없다. 그리고 하나의 학생은 여러 수강내역을 가질수있다.</li>
</ol>
</li>
</ul>
<h2 id="ERD표기법"><a href="#ERD표기법" class="headerlink" title="ERD표기법"></a>ERD표기법</h2><ul>
<li>Baker표기법(DA#)<br>DA표기법은 영국 컨설팅회사 CACI에 의해 처음 개발되었고 리차드 바커에 의햇 지속적으로 업그레이드 되었다. 오라클에서 Case Method로 채택하여 사용.<br>Mandatory 반드시 저장해야될 속성에는 *로 표시, 일반적인 Optional속성에는 o로 표시.<br>관계는 실선을 잘라서 반반씩 표현한다.</li>
<li>IE Notation표기법(ERWin)<br>IE표기법은 Information Engineering Notation은 1981년 발표되었고 80년대 중반 James Martin에 의해 체계가 정리되어 본격적으로 활용되었다. 까마귀발 모델(Crow’s Foot Model)이라고도 한다.<br>식별자는 식별선 위에 따로 표기한다.</li>
</ul>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/klugjo/hexo-theme-clean-blog" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2022 SiriN<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>